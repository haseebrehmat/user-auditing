diff --git a/.env.example b/.env.example
new file mode 100644
index 0000000..e9eeee5
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,5 @@
+DATABASE_USER=
+DATABASE_PASSWORD=
+DATABASE_HOST=
+DATABASE_PORT=
+DATABASE_NAME=
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..7a8b6b1
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,32 @@
+# Python Bytecode
+__pycache__/
+*.py[cod]
+
+# Virtual Environment
+venv/
+.env/
+
+# Database Files
+*.db
+*.sqlite3
+
+# Docker Files
+docker-compose.override.yml
+*.log
+
+# Environment Variables
+.env
+
+# IDE and Editor Files
+.vscode/
+.idea/
+*.swp
+*.sublime-project
+*.sublime-workspace
+
+# Miscellaneous
+*.DS_Store
+*.egg-info/
+dist/
+build/
+postgres_data/
\ No newline at end of file
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..4a9fb24
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,20 @@
+# Use an official Python runtime as a parent image
+FROM python:3.10-slim
+
+# Set the working directory
+WORKDIR /usr/src/app
+
+# Install dependencies
+COPY requirements.txt ./
+RUN pip install --no-cache-dir -r requirements.txt
+
+# Install netcat (choose netcat-openbsd for compatibility)
+RUN apt-get update && apt-get install -y netcat-openbsd && apt-get clean
+
+# Copy the application code
+COPY . .
+
+# Expose the application port
+EXPOSE 8000
+
+# Start the application (handled by docker-compose)
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..2e9ff91
--- /dev/null
+++ b/README.md
@@ -0,0 +1,117 @@
+# üìñ About The Project
+
+This project is a FastAPI-based application for managing user profiles with a full audit log. It ensures that all changes to user profiles are logged for auditing purposes, even when users are updated or deleted. The application integrates PostgreSQL for data persistence and is containerized using Docker.
+
+---
+
+## üõ†Ô∏è Built With
+
+- **[FastAPI](https://fastapi.tiangolo.com/):** A modern, fast web framework for Python.
+- **[PostgreSQL](https://www.postgresql.org/):** Robust relational database for data storage.
+- **[SQLAlchemy](https://www.sqlalchemy.org/):** ORM for database operations.
+- **[Docker](https://www.docker.com/):** For containerization and deployment.
+- **[Pytest](https://pytest.org/):** For automated testing.
+
+---
+
+## üöÄ Getting Started
+
+### Prerequisites
+
+1. Install **Docker** and **Docker Compose**:
+   - [Docker Installation Guide](https://docs.docker.com/get-docker/)
+   - [Docker Compose Installation Guide](https://docs.docker.com/compose/install/)
+
+2. Clone the repository:
+   ```bash
+   git clone <repository_url>
+   cd <project_directory>
+   ```
+
+---
+
+## üì¶ Installation
+
+1. Copy the example `.env` file and update the necessary credentials:
+   ```bash
+   cp .env.example .env
+   ```
+
+2. Build and run the Docker containers:
+   ```bash
+   docker-compose up --build
+   ```
+
+---
+
+## ‚öôÔ∏è Usage
+
+### API Endpoints
+
+#### User Management
+| Method | Endpoint          | Description                     |
+|--------|-------------------|---------------------------------|
+| POST   | `/users/`         | Create a new user profile       |
+| GET    | `/users/`         | List all user profiles          |
+| GET    | `/users/{user_id}`| Retrieve a specific user profile|
+| PUT    | `/users/{user_id}`| Update a user profile           |
+| DELETE | `/users/{user_id}`| Delete a user profile           |
+
+#### Audit Logs
+| Method | Endpoint | Description                         |
+|--------|----------|-------------------------------------|
+| GET    | `/audit` | Retrieve the full audit log         |
+
+### Testing
+
+1. Run tests using `pytest`:
+   ```bash
+   docker-compose exec app pytest
+   ```
+
+---
+
+## üõ§Ô∏è Roadmap
+
+## üóÇÔ∏è Code Information
+
+### Application Files
+
+- **`app/main.py`**: Entry point of the application; initializes routes, database, and FastAPI.
+- **`app/models.py`**: Defines the database models (`User` and `UserAudit`).
+- **`app/schemas.py`**: Pydantic schemas for data validation and serialization.
+- **`app/database/connection.py`**: Manages database connection and session handling.
+- **`app/database/migrations.py`**: Handles database migrations (e.g., creating tables).
+- **`app/database/seeders.py`**: Populates the database with initial seed data.
+- **`app/crud.py`**: Contains CRUD operations for interacting with the database.
+- **`app/services/audit_service.py`**: Business logic for fetching audit logs.
+- **`app/routes`**:
+  - `user_routes.py`: Handles API endpoints for user-related operations.
+  - `audit_routes.py`: Handles API endpoints for audit logs.
+
+### Test Files
+
+- **`tests/test_models.py`**: Unit tests for database models.
+- **`tests/test_schemas.py`**: Tests for Pydantic schemas to ensure data validation.
+- **`tests/test_crud.py`**: Tests for CRUD operations to validate database interactions.
+- **`tests/test_routes.py`**: Integration tests for API routes.
+- **`tests/test_services.py`**: Tests for service logic (e.g., audit log fetching).
+
+---
+
+## üìù Improvements and Future Work
+
+
+- [x] CRUD operations for users.
+- [x] Full audit logging.
+- [x] Dockerized deployment.
+- [x] API testing with Pytest.
+- [ ] Add advanced search/filtering for audit logs.
+- [ ] Add pagination for audit logs & users.
+- [ ] Implement authentication and authorization.
+- [ ] Enhance error handling with custom middlewares.
+
+---
+
+Feel free to contribute or provide feedback! üöÄ
+
diff --git a/app/__init__.py b/app/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/app/crud.py b/app/crud.py
new file mode 100644
index 0000000..ebccf61
--- /dev/null
+++ b/app/crud.py
@@ -0,0 +1,64 @@
+"""
+CRUD operations for database interaction.
+"""
+
+from sqlalchemy.orm import Session
+from app.models import User, UserAudit
+
+
+def create_user(db: Session, name: str, email: str):
+    user = User(name=name, email=email)
+    db.add(user)
+    db.commit()
+    db.refresh(user)
+    log_audit(db, user.id, "create", None, {"name": name, "email": email})
+    return user
+
+
+def log_audit(
+    db: Session, user_id: int, operation: str, previous_data: dict, new_data: dict
+):
+    audit_entry = UserAudit(
+        user_id=user_id,
+        operation=operation,
+        previous_data=previous_data,
+        new_data=new_data,
+    )
+    db.add(audit_entry)
+    db.commit()
+
+
+def get_user_by_id(db: Session, user_id: int):
+    return db.query(User).filter(User.id == user_id).first()
+
+
+def get_all_users(db: Session):
+    return db.query(User).all()
+
+
+def update_user(db: Session, user_id: int, name: str, email: str):
+    user = db.query(User).filter(User.id == user_id).first()
+    if not user:
+        return None
+
+    previous_data = {"name": user.name, "email": user.email}
+    user.name = name
+    user.email = email
+    db.commit()
+    db.refresh(user)
+
+    log_audit(db, user_id, "update", previous_data, {"name": name, "email": email})
+    return user
+
+
+def delete_user(db: Session, user_id: int):
+    user = db.query(User).filter(User.id == user_id).first()
+    if not user:
+        return None
+
+    previous_data = {"name": user.name, "email": user.email}
+    db.delete(user)
+    db.commit()
+
+    log_audit(db, user_id, "delete", previous_data, None)
+    return user
diff --git a/app/db/__init__.py b/app/db/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/app/db/connection.py b/app/db/connection.py
new file mode 100644
index 0000000..4cf1357
--- /dev/null
+++ b/app/db/connection.py
@@ -0,0 +1,52 @@
+"""Database connection, session management, and database readiness check."""
+
+import os
+import time
+from sqlalchemy import create_engine, text
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.exc import OperationalError
+from dotenv import load_dotenv
+
+# Load environment variables
+load_dotenv()
+
+# Database URL construction
+DATABASE_URL = (
+    f"postgresql+psycopg2://{os.getenv('DATABASE_USER')}:{os.getenv('DATABASE_PASSWORD')}"
+    f"@{os.getenv('DATABASE_HOST', 'db')}:{os.getenv('DATABASE_PORT', '5432')}/{os.getenv('DATABASE_NAME')}"
+)
+
+
+def wait_for_db(max_retries=60, retry_interval=1):
+    temp_engine = create_engine(DATABASE_URL)
+
+    for attempt in range(max_retries):
+        try:
+            # Try to connect and execute a simple query
+            with temp_engine.connect() as connection:
+                connection.execute(text("SELECT 1"))
+            print("Database is ready!")
+            temp_engine.dispose()
+            return True
+        except OperationalError as e:
+            if attempt < max_retries - 1:
+                print(f"Waiting for database... (Attempt {attempt + 1}/{max_retries})")
+                time.sleep(retry_interval)
+            else:
+                print("Max retries reached. Database is not available.")
+                raise e
+
+
+# Create engine after ensuring database is available
+if __name__ == "__main__":
+    wait_for_db()
+else:
+    engine = create_engine(DATABASE_URL)
+    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+
+    def get_db():
+        db = SessionLocal()
+        try:
+            yield db
+        finally:
+            db.close()
diff --git a/app/db/migration.py b/app/db/migration.py
new file mode 100644
index 0000000..95dc675
--- /dev/null
+++ b/app/db/migration.py
@@ -0,0 +1,8 @@
+"""
+Database migrations (create tables).
+"""
+from sqlalchemy import Engine
+from app.models import Base
+
+def run_migrations(engine: Engine):
+    Base.metadata.create_all(bind=engine)
\ No newline at end of file
diff --git a/app/main.py b/app/main.py
new file mode 100644
index 0000000..e6b4bf8
--- /dev/null
+++ b/app/main.py
@@ -0,0 +1,18 @@
+"""
+Main application entry point.
+"""
+
+from fastapi import FastAPI
+from app.db.connection import engine
+from app.db.migration import run_migrations
+from app.routes import user_routes, audit_routes
+
+# Initialize database
+run_migrations(engine)
+
+# Initialize the app
+app = FastAPI()
+
+# Include routes
+app.include_router(user_routes.router, prefix="/users", tags=["Users"])
+app.include_router(audit_routes.router, prefix="/audit", tags=["Audit"])
diff --git a/app/models.py b/app/models.py
new file mode 100644
index 0000000..b0f3638
--- /dev/null
+++ b/app/models.py
@@ -0,0 +1,26 @@
+"""
+Database models.
+"""
+
+from sqlalchemy import Column, Integer, String, DateTime, JSON
+from sqlalchemy.orm import declarative_base
+from sqlalchemy.sql import func
+
+Base = declarative_base()
+
+
+class User(Base):
+    __tablename__ = "users"
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String, nullable=False)
+    email = Column(String, unique=True, nullable=False)
+
+
+class UserAudit(Base):
+    __tablename__ = "user_audit"
+    id = Column(Integer, primary_key=True, index=True)
+    user_id = Column(Integer, nullable=False)
+    operation = Column(String, nullable=False)  # "create", "update", "delete"
+    timestamp = Column(DateTime, server_default=func.now())
+    previous_data = Column(JSON, nullable=True)
+    new_data = Column(JSON, nullable=True)
diff --git a/app/routes/__init__.py b/app/routes/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/app/routes/audit_routes.py b/app/routes/audit_routes.py
new file mode 100644
index 0000000..71ff0c3
--- /dev/null
+++ b/app/routes/audit_routes.py
@@ -0,0 +1,16 @@
+"""
+Routes for audit-related operations.
+"""
+
+from fastapi import APIRouter, Depends
+from sqlalchemy.orm import Session
+from app.schemas import UserAuditResponse
+from app.db.connection import get_db
+from app.services.audit_service import fetch_audit_logs
+
+router = APIRouter()
+
+
+@router.get("/", response_model=list[UserAuditResponse])
+def get_audit_logs_route(db: Session = Depends(get_db)):
+    return fetch_audit_logs(db)
diff --git a/app/routes/user_routes.py b/app/routes/user_routes.py
new file mode 100644
index 0000000..25f080b
--- /dev/null
+++ b/app/routes/user_routes.py
@@ -0,0 +1,55 @@
+"""
+Routes for user-related operations.
+"""
+
+from fastapi import APIRouter, HTTPException, Depends
+from sqlalchemy.orm import Session
+from app.schemas import UserCreate, UserResponse
+from app.db.connection import get_db
+from app.crud import (
+    create_user,
+    get_user_by_id,
+    get_all_users,
+    update_user,
+    delete_user,
+)
+from app.models import User
+
+router = APIRouter()
+
+
+@router.post("/", response_model=UserResponse)
+def create_user_route(user: UserCreate, db: Session = Depends(get_db)):
+    existing_user = db.query(User).filter(User.email == user.email).first()
+    if existing_user:
+        raise HTTPException(status_code=400, detail="Email already registered")
+    return create_user(db, user.name, user.email)
+
+
+@router.get("/", response_model=list[UserResponse])
+def list_users_route(db: Session = Depends(get_db)):
+    return get_all_users(db)
+
+
+@router.get("/{user_id}", response_model=UserResponse)
+def get_user_route(user_id: int, db: Session = Depends(get_db)):
+    user = get_user_by_id(db, user_id)
+    if not user:
+        raise HTTPException(status_code=404, detail="User not found")
+    return user
+
+
+@router.put("/{user_id}", response_model=UserResponse)
+def update_user_route(user_id: int, user: UserCreate, db: Session = Depends(get_db)):
+    updated_user = update_user(db, user_id, user.name, user.email)
+    if not updated_user:
+        raise HTTPException(status_code=404, detail="User not found")
+    return updated_user
+
+
+@router.delete("/{user_id}", response_model=UserResponse)
+def delete_user_route(user_id: int, db: Session = Depends(get_db)):
+    deleted_user = delete_user(db, user_id)
+    if not deleted_user:
+        raise HTTPException(status_code=404, detail="User not found")
+    return deleted_user
diff --git a/app/schemas.py b/app/schemas.py
new file mode 100644
index 0000000..3c8eee9
--- /dev/null
+++ b/app/schemas.py
@@ -0,0 +1,47 @@
+"""
+Pydantic schemas for data validation and serialization.
+"""
+
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, EmailStr
+
+
+class UserBase(BaseModel):
+    name: str
+    email: EmailStr
+
+
+class UserCreate(UserBase):
+    pass
+
+
+class UserResponse(UserBase):
+    id: int
+    model_config = ConfigDict(from_attributes=True)
+
+
+
+class UserAuditResponse(BaseModel):
+    id: int
+    user_id: int
+    operation: str
+    timestamp: datetime  # Use datetime here and format it explicitly in the response
+    previous_data: dict | None
+    new_data: dict | None
+
+    model_config = ConfigDict(from_attributes=True)
+
+
+    @staticmethod
+    def format_timestamp(value: datetime) -> str:
+        return value.isoformat()
+
+    @classmethod
+    def __get_validators__(cls):
+        yield cls.validate
+
+    @classmethod
+    def validate(cls, value: dict):
+        if "timestamp" in value and isinstance(value["timestamp"], datetime):
+            value["timestamp"] = cls.format_timestamp(value["timestamp"])
+        return value
diff --git a/app/services/__init__.py b/app/services/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/app/services/audit_service.py b/app/services/audit_service.py
new file mode 100644
index 0000000..a61fccd
--- /dev/null
+++ b/app/services/audit_service.py
@@ -0,0 +1,11 @@
+"""
+Service layer for audit operations.
+"""
+
+from sqlalchemy.orm import Session
+from app.models import UserAudit
+
+
+def fetch_audit_logs(db: Session):
+    """Fetch all audit logs."""
+    return db.query(UserAudit).all()
diff --git a/compose.yml b/compose.yml
new file mode 100644
index 0000000..7cbc751
--- /dev/null
+++ b/compose.yml
@@ -0,0 +1,51 @@
+services:
+  app:
+    build: .
+    ports:
+      - "8000:8000"
+    env_file:
+      - .env
+    depends_on:
+      db:
+        condition: service_healthy
+    volumes:
+      - .:/usr/src/app
+    networks:
+      - postgres_network
+    command: >
+      sh -c "
+      while ! nc -z db 5432;
+      do
+        echo 'Waiting for PostgreSQL...';
+        sleep 1;
+      done;
+      uvicorn app.main:app --host 0.0.0.0 --port 8000
+      "
+
+  db:
+    image: postgres:14
+    env_file:
+      - .env
+    environment:
+      POSTGRES_USER: ${DATABASE_USER}
+      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
+      POSTGRES_DB: ${DATABASE_NAME}
+      POSTGRES_HOST_AUTH_METHOD: trust
+    ports:
+      - "5432:${DATABASE_PORT}"
+    volumes:
+      - ./postgres_data:/var/lib/postgresql/data
+    networks:
+      - postgres_network
+    healthcheck:
+      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER} -d ${DATABASE_NAME}"]
+      interval: 10s
+      timeout: 5s
+      retries: 5
+
+volumes:
+  postgres_data:
+
+networks:
+  postgres_network:
+    driver: bridge
diff --git a/pytest.ini b/pytest.ini
new file mode 100644
index 0000000..0102b0a
--- /dev/null
+++ b/pytest.ini
@@ -0,0 +1,2 @@
+[pytest]
+asyncio_default_fixture_loop_scope = function
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..bc52634
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,25 @@
+annotated-types==0.7.0
+anyio==4.8.0
+click==8.1.8
+dnspython==2.7.0
+email_validator==2.2.0
+exceptiongroup==1.2.2
+fastapi==0.115.6
+greenlet==3.1.1
+h11==0.14.0
+idna==3.10
+iniconfig==2.0.0
+packaging==24.2
+pluggy==1.5.0
+psycopg2-binary==2.9.10
+pydantic==2.10.5
+pydantic_core==2.27.2
+pytest==8.3.4
+pytest-asyncio==0.25.2
+python-dotenv==1.0.1
+sniffio==1.3.1
+SQLAlchemy==2.0.37
+starlette==0.41.3
+tomli==2.2.1
+typing_extensions==4.12.2
+uvicorn==0.34.0
\ No newline at end of file
diff --git a/tests/__init__.py b/tests/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000..325d299
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,24 @@
+import pytest
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from app.models import Base
+
+# Use an in-memory SQLite database for testing
+TEST_DATABASE_URL = "sqlite:///:memory:"
+
+# Create a test engine and session
+engine = create_engine(TEST_DATABASE_URL, connect_args={"check_same_thread": False})
+SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+
+
+@pytest.fixture(scope="module")
+def db_session():
+    # Create the tables in the test database
+    Base.metadata.create_all(bind=engine)
+    session = SessionLocal()
+    try:
+        yield session
+    finally:
+        session.close()
+        # Drop the tables after the test
+        Base.metadata.drop_all(bind=engine)
diff --git a/tests/test_crud.py b/tests/test_crud.py
new file mode 100644
index 0000000..1af781a
--- /dev/null
+++ b/tests/test_crud.py
@@ -0,0 +1,20 @@
+"""
+Tests for CRUD operations.
+"""
+
+from app.crud import (
+    create_user,
+    get_user_by_id
+)
+from sqlalchemy.orm import Session
+
+
+def test_create_user_crud(db_session: Session):
+    user = create_user(db_session, name="Jane Doe", email="jane.doe@example.com")
+    assert user.name == "Jane Doe"
+    assert user.email == "jane.doe@example.com"
+
+
+def test_get_user_by_id_crud(db_session: Session):
+    user = get_user_by_id(db_session, user_id=1)
+    assert user is not None
diff --git a/tests/test_models.py b/tests/test_models.py
new file mode 100644
index 0000000..733a61b
--- /dev/null
+++ b/tests/test_models.py
@@ -0,0 +1,19 @@
+"""
+Tests for SQLAlchemy models.
+"""
+
+from app.models import User, UserAudit
+
+
+def test_user_model():
+    user = User(name="John Doe", email="john.doe@example.com")
+    assert user.name == "John Doe"
+    assert user.email == "john.doe@example.com"
+
+
+def test_user_audit_model():
+    audit = UserAudit(
+        user_id=1, operation="create", previous_data={}, new_data={"name": "John Doe"}
+    )
+    assert audit.user_id == 1
+    assert audit.operation == "create"
diff --git a/tests/test_schemas.py b/tests/test_schemas.py
new file mode 100644
index 0000000..4c9cc06
--- /dev/null
+++ b/tests/test_schemas.py
@@ -0,0 +1,26 @@
+"""
+Tests for Pydantic schemas.
+"""
+
+from app.schemas import UserResponse, UserAuditResponse
+from datetime import datetime, timezone
+
+
+def test_user_response_schema():
+    user_data = {"id": 1, "name": "John Doe", "email": "john.doe@example.com"}
+    user = UserResponse(**user_data)
+    assert user.id == 1
+    assert user.name == "John Doe"
+
+
+def test_user_audit_response_schema():
+    audit_data = {
+        "id": 1,
+        "user_id": 1,
+        "operation": "create",
+        "timestamp": datetime.now(timezone.utc),  # Use timezone-aware datetime
+        "previous_data": {},
+        "new_data": {"name": "John Doe"},
+    }
+    audit = UserAuditResponse(**audit_data)
+    assert audit.operation == "create"
\ No newline at end of file
diff --git a/tests/test_services.py b/tests/test_services.py
new file mode 100644
index 0000000..084cdf4
--- /dev/null
+++ b/tests/test_services.py
@@ -0,0 +1,12 @@
+"""
+Tests for service logic.
+"""
+
+from app.services.audit_service import fetch_audit_logs
+from sqlalchemy.orm import Session
+
+
+def test_fetch_audit_logs(db_session: Session):
+    audits = fetch_audit_logs(db_session)
+    assert audits is not None
+    assert isinstance(audits, list)
